{"componentChunkName":"component---src-templates-page-tsx","path":"/concepts/state/","result":{"data":{"site":{"siteMetadata":{"title":"HPCCSystems Solutions Lab","sidebarTitle":"HPCCSystems Solutions Lab","sidebarSubtext":"Documentation","siteLastUpdated":"2020-06-05T21:56:30.418Z","description":"HPCC Systems is a mature platform that has been heavily used in commercial applications for almost two decades, predating the development of Hadoop. Created by LexisNexis Risk Solutions, an innovative pioneer in big data processing, and open source for nearly a decade now, HPCC Systems features a vibrant development community that continues to push the boundaries of big data.","version":"3.5.5","siteUrl":"https://docs.kata.ai","keywords":"hpcc, hpccsystems, ecl","author":{"name":"HPCCSystems.com","url":"https://hpccsystems.com","email":"info@hpccsystems.com"},"socials":[{"name":"Twitter","imgpath":"icon-twitter.svg","url":"https://twitter.com/KataDotAI"},{"name":"GitHub","imgpath":"icon-github.svg","url":"https://github.com/kata-ai"},{"name":"LinkedIn","imgpath":"icon-linkedin.svg","url":"https://www.linkedin.com/company/yesboss/"},{"name":"Medium","imgpath":"icon-medium.svg","url":"https://medium.com/kata-engineering"}]}},"sectionList":{"edges":[{"node":{"title":"Advanced Concepts","items":[{"id":"FUNCTION","slug":"/hpcc/LearnECL/AdvanceConcepts/function","title":"FUNCTION"},{"id":"JOIN","slug":"/hpcc/LearnECL/AdvanceConcepts/join","title":"JOIN"},{"id":"MODULE","slug":"/hpcc/LearnECL/AdvanceConcepts/module","title":"MODULE"},{"id":"PROJECT","slug":"/hpcc/LearnECL/AdvanceConcepts/project","title":"PROJECT"},{"id":"TABLE","slug":"/hpcc/LearnECL/AdvanceConcepts/table","title":"TABLE"},{"id":"TRANSFORM","slug":"/hpcc/LearnECL/AdvanceConcepts/transform","title":"TRANSFORM"}]}},{"node":{"title":"Main Concepts","items":[{"id":"dataset","slug":"/hpcc/LearnECL/MainConcepts/dataset","title":"DATASET"},{"id":"filter","slug":"/hpcc/LearnECL/MainConcepts/filter","title":"FILTER"},{"id":"introducingECL","slug":"/hpcc/LearnECL/MainConcepts/introducingECL","title":"INTRODUCING ECL"},{"id":"mathematics","slug":"/hpcc/LearnECL/MainConcepts/mathematics","title":"MATHEMATICS"},{"id":"namingConvension","slug":"/hpcc/LearnECL/MainConcepts/namingConvension","title":"NAMING CONVENTION"},{"id":"output","slug":"/hpcc/LearnECL/MainConcepts/output","title":"OUTPUT"},{"id":"recordstructure","slug":"/hpcc/LearnECL/MainConcepts/recordStructure","title":"RECORD Structure"},{"id":"sort","slug":"/hpcc/LearnECL/MainConcepts/sort","title":"SORT"}]}}]},"markdownRemark":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"State represents the stage of the conversation. Imagine you are a Customer Service agent, you will provided with an SOP that requires you to respond appropriately in every state / stage of conversation. The state concept is basically a finite state machine with initial and end states."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"./images/state/figure-1.png","alt":"Figure 1"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"We have discussed the three conversation phase: intent recognition, state mapping and action selection. In the state mapping phase, the parsed message together with current state, context and data will be mapped into a new state, updated context, and data."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"./images/state/figure-2.png","alt":"Figure 2"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"A state can have an action or multiple actions attached that is being triggered at the end of state mapping lifecyle."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Lifecycle"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The lifecycle of a state mapping process is following:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"It starts from the last state (or init state if no last state is found)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"It will execute transit mapping, if it is defined"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"It will search for available transition that meet condition, otherwise it will choose the fallback transition"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"If a transition is chosen, it will execute transition mapping"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"It will execute exit mapping"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"It will execute enter mapping of the next state"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"it will return the updated state, context and data"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"The actions of the new state will be triggered"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Initial State"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Every state mapping process must start from a state. If a flow is newly created, then it will start from the initial state. A flow can only have one initial state. There is two styles of initial state: the so called pitcher init or guardian init."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"./images/state/figure-3.png","alt":"Figure 3"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The pitcher init is an initial state that only used to start a flow and will never be revisited again. This style of init doesn't need to have an action attached, since it will never be the destination state."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-yaml"]},"children":[{"type":"text","value":"states:\n  init:\n    initial: true\n    transitions:\n      hi:\n        condition: content == \"hi\"\n      sorry:\n        fallback: true\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The second style is guardian init. This type of initial state will be revisited, until certain outcome (context change) is reached. Since this kind of init can be the destination state, it must have action attached."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-yaml"]},"children":[{"type":"text","value":"states:\n  inquireName:\n    initial: true\n    transitions:\n      inquirePhone:\n        condition: context.name\n      inquireName:\n        fallback: true\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"End State"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"A flow shall have at least one end-state. End state will cause a flow to be closed, which means that all the context associated with that flow will be erased. The flow will neither exist in the flow stack nor in the current flow anymore. A closed flow can be reopened with message that trigger its initial intent."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-yaml"]},"children":[{"type":"text","value":"states:\n  close:\n    end: true\n    action: thankYou\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"An end state doesn't have to have a transition, since from there you can't get nowhere else."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Transition"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"In every conversation, a state must go to its next state, even if the next state is the same state as the previous. To accomodate the state movement, transitions need to be defined. The state mapper process will do following procedure in selecting transition:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"It will select possible transitions with matching conditions"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"If more than one transitions are selected, it will choose one with higher priority or higher order"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"If no transition is selected, then it will select fallback transition"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-yaml"]},"children":[{"type":"text","value":"transitions:\n  stateA:\n    condition: context.a == 1\n  stateB:\n    condition: context.a == 2\n  stateC:\n    fallback: true\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Note: since the system require next state to be defined, a fallback transition shall be defined for every state."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Mapping"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Mapping is a process of updating the context and data. The mapping syntax is a key-value pair where the key is the context / data variables you want to be updated and the value is the value that you want to be mapped into the variable of your choice. Example:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-yaml"]},"children":[{"type":"text","value":"myState:\n  transit:\n    context.person.name: attributes.name || context.person.name\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"You can use valid javascript expression in the mapping. You can also define nested fields in the key part. There are multiple lifecycle events where you can put your mappings:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"transit"}]},{"type":"text","value":" before selecting transition"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"transition mapping"}]},{"type":"text","value":" during transition"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"exit"}]},{"type":"text","value":" after selecting transition"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"enter"}]},{"type":"text","value":" after moving into new state"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Following variables can be accessed:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"content"}]},{"type":"text","value":" message content"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"payload"}]},{"type":"text","value":" message payload"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"type"}]},{"type":"text","value":" message type"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"metadata"}]},{"type":"text","value":" message metadata"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"intent"}]},{"type":"text","value":" message intent"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"attributes"}]},{"type":"text","value":" message attributes"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"context"}]},{"type":"text","value":" flow context"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"data"}]},{"type":"text","value":" session data"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Additional meta context accessible in states at "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"context.<meta>"}]},{"type":"text","value":":"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"start : boolean"}]},{"type":"text","value":" true if state is initial state"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"to : string"}]},{"type":"text","value":" describe destination state. Available during exit"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"from : string"}]},{"type":"text","value":" describe origin state. Available during enter"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"end : boolean"}]},{"type":"text","value":" true if state is end state"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Floating State"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Occasionally you will get into case where you need to put transition from many states to a particular state. E.g. cancel state. To simplify those cases, you can define a floating state. A floating state is a state that is reachable from all other states. When you define a state to be a floating state, the system will automatically create transitions from every other states to that state."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-yaml"]},"children":[{"type":"text","value":"states:\n  cancel:\n    float:\n      condition: intent == \"cancel\"\n"}]}]}],"data":{"quirksMode":false}},"tableOfContents":"<ul>\n<li><a href=\"/hpcc-solutions-lab/concepts/state/#lifecycle\">Lifecycle</a></li>\n<li><a href=\"/hpcc-solutions-lab/concepts/state/#initial-state\">Initial State</a></li>\n<li><a href=\"/hpcc-solutions-lab/concepts/state/#end-state\">End State</a></li>\n<li><a href=\"/hpcc-solutions-lab/concepts/state/#transition\">Transition</a></li>\n<li><a href=\"/hpcc-solutions-lab/concepts/state/#mapping\">Mapping</a></li>\n<li><a href=\"/hpcc-solutions-lab/concepts/state/#floating-state\">Floating State</a></li>\n</ul>","excerpt":"State represents the stage of the conversation. Imagine you are a Customer Service agent, you will provided with an SOP that requires you to…","frontmatter":{"id":"state","title":"State","description":null,"prev":"intent","next":"action"},"fields":{"slug":"/concepts/state/"}},"allFile":{"edges":[{"node":{"gitRemote":{"webLink":"https://alfjjacob:58e9fd5edbad4eccf8bb133c55491be00091f1c7@github.com/hpccsystems-solutions-lab/Learn-ECL","ref":"master","pathname":"/hpccsystems-solutions-lab/Learn-ECL.git","organization":"hpccsystems-solutions-lab","name":"Learn-ECL"}}},{"node":{"gitRemote":{"webLink":"https://alfjjacob:58e9fd5edbad4eccf8bb133c55491be00091f1c7@github.com/hpccsystems-solutions-lab/ECL-Pattern-Job-Scheduling","ref":"master","pathname":"/hpccsystems-solutions-lab/ECL-Pattern-Job-Scheduling.git","organization":"hpccsystems-solutions-lab","name":"ECL-Pattern-Job-Scheduling"}}},{"node":{"gitRemote":{"webLink":"https://alfjjacob:58e9fd5edbad4eccf8bb133c55491be00091f1c7@github.com/hpccsystems-solutions-lab/CodeDay_May2020","ref":"master","pathname":"/hpccsystems-solutions-lab/CodeDay_May2020.git","organization":"hpccsystems-solutions-lab","name":"CodeDay_May2020"}}},{"node":{"gitRemote":{"webLink":"https://alfjjacob:58e9fd5edbad4eccf8bb133c55491be00091f1c7@github.com/hpccsystems-solutions-lab/ECL-Sample-Cheatsheet","ref":"master","pathname":"/hpccsystems-solutions-lab/ECL-Sample-Cheatsheet.git","organization":"hpccsystems-solutions-lab","name":"ECL-Sample-Cheatsheet"}}}]}},"pageContext":{"slug":"/concepts/state/"}}}