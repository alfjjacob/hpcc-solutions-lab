{"componentChunkName":"component---src-templates-page-tsx","path":"/hpcc/LearnECL/Parsing/nlp/","result":{"data":{"site":{"siteMetadata":{"title":"HPCCSystems Solutions Lab","sidebarTitle":"HPCCSystems Solutions Lab","sidebarSubtext":"Documentation","siteLastUpdated":"2020-06-05T21:56:30.418Z","description":"HPCC Systems is a mature platform that has been heavily used in commercial applications for almost two decades, predating the development of Hadoop. Created by LexisNexis Risk Solutions, an innovative pioneer in big data processing, and open source for nearly a decade now, HPCC Systems features a vibrant development community that continues to push the boundaries of big data.","version":"3.5.5","siteUrl":"https://docs.kata.ai","keywords":"hpcc, hpccsystems, ecl","author":{"name":"HPCCSystems.com","url":"https://hpccsystems.com","email":"info@hpccsystems.com"},"socials":[{"name":"Twitter","imgpath":"icon-twitter.svg","url":"https://twitter.com/KataDotAI"},{"name":"GitHub","imgpath":"icon-github.svg","url":"https://github.com/kata-ai"},{"name":"LinkedIn","imgpath":"icon-linkedin.svg","url":"https://www.linkedin.com/company/yesboss/"},{"name":"Medium","imgpath":"icon-medium.svg","url":"https://medium.com/kata-engineering"}]}},"sectionList":{"edges":[{"node":{"title":"Advanced Concepts","items":[{"id":"FUNCTION","slug":"/hpcc/LearnECL/AdvanceConcepts/function","title":"FUNCTION"},{"id":"JOIN","slug":"/hpcc/LearnECL/AdvanceConcepts/join","title":"JOIN"},{"id":"MODULE","slug":"/hpcc/LearnECL/AdvanceConcepts/module","title":"MODULE"},{"id":"PROJECT","slug":"/hpcc/LearnECL/AdvanceConcepts/project","title":"PROJECT"},{"id":"TABLE","slug":"/hpcc/LearnECL/AdvanceConcepts/table","title":"TABLE"},{"id":"TRANSFORM","slug":"/hpcc/LearnECL/AdvanceConcepts/transform","title":"TRANSFORM"}]}},{"node":{"title":"Main Concepts","items":[{"id":"dataset","slug":"/hpcc/LearnECL/MainConcepts/dataset","title":"DATASET"},{"id":"filter","slug":"/hpcc/LearnECL/MainConcepts/filter","title":"FILTER"},{"id":"introducingECL","slug":"/hpcc/LearnECL/MainConcepts/introducingECL","title":"INTRODUCING ECL"},{"id":"mathematics","slug":"/hpcc/LearnECL/MainConcepts/mathematics","title":"MATHEMATICS"},{"id":"namingConvension","slug":"/hpcc/LearnECL/MainConcepts/namingConvension","title":"NAMING CONVENTION"},{"id":"output","slug":"/hpcc/LearnECL/MainConcepts/output","title":"OUTPUT"},{"id":"recordstructure","slug":"/hpcc/LearnECL/MainConcepts/recordStructure","title":"RECORD Structure"},{"id":"sort","slug":"/hpcc/LearnECL/MainConcepts/sort","title":"SORT"}]}}]},"markdownRemark":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"NLP"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"NLP (Natural Language Parsing) is the process of determining the syntactic structure of a text by analyzing its constituent words based on an underlying grammar."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"String Parsing"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"String parsing, or syntactic analysis is the process of analyzing a string of symbols, either in natural language, computer languages or data structures, conforming to the rules of a formal grammar."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"How it's done"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"To parse (pattern match) content/text, start by defining your PATTERNS, and defining your end result record structure, then use the PARSE function to go over your content."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"PATTERN"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Defines the specific text to be searched/detected in the content. Start parse patterns by creating \"atomic\" bits and then growing them into more complex patterns as you go. So the first thing we need to do is define the atomic level of patterns. Patterns use Perl standard regular expressions to define a matching character sequences."},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\nWhen defining a pattern, you basically assigning type of pattern to an attribute. \\"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"PATTERN attribute name := PATTERN ();"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Any number of alpha characters together:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"PATTERN Alpha := PATTERN('[A-Z]')+;\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Single numeric digit:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"PATTERN Nbr := PATTERN('[0-9]');\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Separators -- including \"space\" character:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"PATTERN Sep := PATTERN('[-, /.]');\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Space, tab, new line, and return characters are all white space:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"PATTERN ws := PATTERN('[ \\t\\r\\n]');\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OPT"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Everything within the parenthesis is optional. Opt and regular expression can be used to build more complex patterns."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"\"white space\" = 1 or 2 separators:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"PATTERN Ws := Sep OPT(Sep);\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"1 or 2-digit number:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"PATTERN Num12 := OPT(Nbr) Nbr;\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"2 or 4-digit number:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"PATTERN Year := Nbr Nbr OPT(Nbr Nbr);\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"2 or 4-digit number using regular expression:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"PATTERN Year := Nbr*2 OPT(Nbr*2);\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Complex Pattern"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Patterns are used to show different ways of representing search patterns. They can be combined using logical OR (|) to build final Pattern."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"In the following example, two different types of time patterns, AMPM and Zulu are used to build a final pattern(time)."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"//AMPM: A numeric pattern ending with a non-optional Alpha pattern.\n//Zulu: Purely numeric pattern, three instances of Num12 delimited by colons,\n//giving us hours, minutes and seconds.\n\nPATTERN Alpha := PATTERN('[A-Z]')+;\nPATTERN AMPM  := Num12 ':' Num12 OPT(':' Num12) ' ' Alpha;\nPATTERN Zulu  := Num12 ':' Num12 ':' Num12;\nPATTERN Time  := (AMPM | Zulu); // | logical OR\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"TRANSFORM Functions"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Followings are used with in conjunctions with Transform for parsing purposes."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"MATCHED("},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"pattern"}]},{"type":"text","value":")"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Returns true or false as to whether the named pattern found a match."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"MATCHTEXT(["},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"pattern"}]},{"type":"text","value":"])"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Returns the matching ASCII text the Pattern found. If a named is omitted, MATCHTEXT returns all matching text."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"MATCHUNICODE(["},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"pattern"}]},{"type":"text","value":"])"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Returns the matching Unicode text the named pattern found. If a named is omitted, MATCHUNICODE returns all matching Unicode text."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Validate Function"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"VALIDATE(pattern, isValidExpression)"}]},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\nCheck the validity of the pattern. "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"isValidExpression"}]},{"type":"text","value":" is an expression or function that returns a Boolean and should use MATCHTEXT or MATCHUNICODE to refer to the text that matched the pattern."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"PATTERN Alpha := PATTERN('[A-Z]')+;\nSetMonths := ['JAN','FEB','MAR','APR','MAY','JUN','JUL','AUG','SEP','OCT','NOV','DEC'];\n\n//inline function: evaluate the first 3 charcters of the text.\nisValidMonth(STRING txt) := txt[1..3] IN SetMonths;\nPATTERN Month := VALIDATE(Alpha,isValidMonth(MATCHTEXT)) ;\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"RULE"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Defines our final pattern possibilities, combined with logical OR (|). The patterns are treated as Tokens."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RULE DateRule := (NumDate | AlphaDate1 | AlphaDate2);\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"TOKEN"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The TOKEN value type defines a parsing expression very similar to a PATTERN, but once matched, the parser doesn't backtrack to find alternative matches as it would with PATTERN."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"PARSE"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Processes an input dataset much like NORMALIZE does, parsing a given field's data to see if it satisfies a given rule, producing a result set of those matches via a TRANSFORM. If multiple results are found they all will be returned."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\nLet's look at an example: "},{"type":"element","tagName":"a","properties":{"href":"/hpcc-solutions-lab/source/ecl/DateParsingOne.ecl"},"children":[{"type":"text","value":"DateParsingOne.ecl"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"References"}]},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"a","properties":{"href":"https://hpccsystems.com/blog/Tips_and_Tricks_for_ECL_Part2_PARSE"},"children":[{"type":"text","value":"Parsing tips and tricks by Richard Taylor"}]}]}],"data":{"quirksMode":false}},"tableOfContents":"<ul>\n<li><a href=\"/hpcc-solutions-lab/hpcc/LearnECL/Parsing/nlp/#nlp\">NLP</a></li>\n<li><a href=\"/hpcc-solutions-lab/hpcc/LearnECL/Parsing/nlp/#string-parsing\">String Parsing</a></li>\n<li>\n<p><a href=\"/hpcc-solutions-lab/hpcc/LearnECL/Parsing/nlp/#how-its-done\">How it's done</a></p>\n<ul>\n<li><a href=\"/hpcc-solutions-lab/hpcc/LearnECL/Parsing/nlp/#pattern\">PATTERN</a></li>\n<li>\n<p><a href=\"/hpcc-solutions-lab/hpcc/LearnECL/Parsing/nlp/#opt\">OPT</a></p>\n<ul>\n<li><a href=\"/hpcc-solutions-lab/hpcc/LearnECL/Parsing/nlp/#complex-pattern\">Complex Pattern</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"/hpcc-solutions-lab/hpcc/LearnECL/Parsing/nlp/#transform-functions\">TRANSFORM Functions</a></p>\n<ul>\n<li><a href=\"/hpcc-solutions-lab/hpcc/LearnECL/Parsing/nlp/#matchedpattern\">MATCHED(pattern)</a></li>\n<li><a href=\"/hpcc-solutions-lab/hpcc/LearnECL/Parsing/nlp/#matchtextpattern\">MATCHTEXT(pattern)</a></li>\n<li><a href=\"/hpcc-solutions-lab/hpcc/LearnECL/Parsing/nlp/#matchunicodepattern\">MATCHUNICODE(pattern)</a></li>\n</ul>\n</li>\n<li><a href=\"/hpcc-solutions-lab/hpcc/LearnECL/Parsing/nlp/#validate-function\">Validate Function</a></li>\n<li><a href=\"/hpcc-solutions-lab/hpcc/LearnECL/Parsing/nlp/#rule\">RULE</a></li>\n<li><a href=\"/hpcc-solutions-lab/hpcc/LearnECL/Parsing/nlp/#token\">TOKEN</a></li>\n<li><a href=\"/hpcc-solutions-lab/hpcc/LearnECL/Parsing/nlp/#parse\">PARSE</a></li>\n</ul>\n</li>\n</ul>","excerpt":"NLPNLP (Natural Language Parsing) is the process of determining the syntactic structure of a text by analyzing its constituent words basedâ€¦","frontmatter":{"id":null,"title":"","description":null,"prev":null,"next":null},"fields":{"slug":"/hpcc/LearnECL/Parsing/nlp/"}},"allFile":{"edges":[{"node":{"gitRemote":{"webLink":"https://alfjjacob:58e9fd5edbad4eccf8bb133c55491be00091f1c7@github.com/hpccsystems-solutions-lab/Learn-ECL","ref":"master","pathname":"/hpccsystems-solutions-lab/Learn-ECL.git","organization":"hpccsystems-solutions-lab","name":"Learn-ECL"}}},{"node":{"gitRemote":{"webLink":"https://alfjjacob:58e9fd5edbad4eccf8bb133c55491be00091f1c7@github.com/hpccsystems-solutions-lab/ECL-Pattern-Job-Scheduling","ref":"master","pathname":"/hpccsystems-solutions-lab/ECL-Pattern-Job-Scheduling.git","organization":"hpccsystems-solutions-lab","name":"ECL-Pattern-Job-Scheduling"}}},{"node":{"gitRemote":{"webLink":"https://alfjjacob:58e9fd5edbad4eccf8bb133c55491be00091f1c7@github.com/hpccsystems-solutions-lab/CodeDay_May2020","ref":"master","pathname":"/hpccsystems-solutions-lab/CodeDay_May2020.git","organization":"hpccsystems-solutions-lab","name":"CodeDay_May2020"}}},{"node":{"gitRemote":{"webLink":"https://alfjjacob:58e9fd5edbad4eccf8bb133c55491be00091f1c7@github.com/hpccsystems-solutions-lab/ECL-Sample-Cheatsheet","ref":"master","pathname":"/hpccsystems-solutions-lab/ECL-Sample-Cheatsheet.git","organization":"hpccsystems-solutions-lab","name":"ECL-Sample-Cheatsheet"}}}]}},"pageContext":{"slug":"/hpcc/LearnECL/Parsing/nlp/"}}}